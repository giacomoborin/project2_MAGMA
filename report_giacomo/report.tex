\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amssymb,amsmath,amsthm,mathtools} 
\usepackage{tikz-cd,wrapfig}
\usepackage{tcolorbox}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{enumitem}
\usepackage{pdfsync}
\usepackage{amstext} % for \text macro
\usepackage{array}   % for \newcolumntype macro
% \newcolumntype{C}{>{$}c<{$}} % math-mode version of "C" column type
%Personal package
\usepackage{listings}
\usepackage{lstlang0}
\usepackage{bm}
\usepackage{csquotes}


%Commands
\newcommand{\DD}{\mathcal{D}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\PP}{\mathbb{P}}
\DeclareMathOperator{\sgn}{sgn}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\FT}{\mathcal{F}}
\DeclareMathOperator*{\eqb}{=}
\DeclareMathOperator{\ifff}{\iff}


% Theorem definitons 
\theoremstyle{plain}
\newtheorem{teo}{Theorem}[section]
\newtheorem{lem}[teo]{Lemma}
\newtheorem{prop}[teo]{Proposition}
\newtheorem{cor}[teo]{Corollary}
\newtheorem*{form}{Formula}

\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newtheorem{rems}[rem]{Remarks}
\newtheorem{idea}[rem]{Idea}


\theoremstyle{definition}
\newtheorem{deff}[teo]{Definiton}
\newtheorem{algo}[teo]{Algorithm}
\newtheorem{prob}[teo]{Problem}
\newtheorem*{nota}{Notation}

%Bibliography
\usepackage[backend=biber, style=alphabetic, maxnames = 8, giveninits=true,isbn=false,eprint=false]{biblatex}
%other_styles:numeric_authortitle
\addbibresource{biblio.bib}


\usepackage{hyperref}



\title{Report for the MAGMA project}
\author{Giacomo Borin}

\begin{document}

\maketitle

\begin{abstract}
	The report contain the implementation of 5 algorithms:
	\begin{itemize}
		\item ECDSA, a digital signature scheme based on algebraic curves.
		\item Pohlig Hellman alorithm for solving discrete logarithm problem for Algebraic curves. Particularly efficient when the base point has order with only small primes in the factorization
		\item Index Calculus algorithm for solving discrete logarithm problem for in finite fields of prime order using linear algebra and B-smooth sieving.
		\item Solovay-Strassen primality test, based on the evaluation of the Jacobi Symbol.
		\item Lehman factorization algorithm, based on a modification of the Fermat factorization algorithm.
	\end{itemize}

	The requests for the report are:


	Assuming that a team has passed the first phase, then each team member must submit an individual report on the project. The report must be written in English and not more than 15 pages.
	The report must include the following:
	\begin{itemize}
		\item your personal contribution to the team project (0-2 points)
		\item a complete overview of the mathematical problems behind the algorithms (0-4
points)
		\item an in-depth explanation of the implementative choices (0-4 points)
	\end{itemize}
	You must also submit the code of the project. This may include some improvements that you personally added after the project submission.


\end{abstract}

\subsection*{General considerations}

In general functions already implemented in MAGMA are significantly faster than ours, so when possible we have used them. 


\section{ECDSA}

We have implemented the algorithm from~\cite[Section 6.6]{washington}.

I've personally implemented all the code and a good part of the test vectors(it didn't took a lot of time), while Dario helped with debugging.

\subsection{Implementation choiches}

- following the washington

It would be faster to use $k = 4$ as Sony, since it simplifies a lot the evaluation of $kG$ (in fact it would require only two doublings) but it would be very bad for security. However I have tried to use again the idea at the commit \href{https://github.com/giacomoborin/project2_MAGMA/commit/1209afbbb3bed86d26ebf342bf6f43453de3e795}{1209afb}.

Some evaluation can be seen in the \href{https://github.com/giacomoborin/project2_MAGMA/pull/36}{associated pull request}.

%\begin{lstlisting}[language = magma]
%> load "ECDSA.mag"; // k random
%Loading "ECDSA.mag"
%> load "Test_ECDSA.mag";
%Loading "Test_ECDSA.mag"
%Time: 6.130
%> load "ECDSA.mag"; // k = 4    
%Loading "ECDSA.mag"
%> load "Test_ECDSA.mag";
%Loading "Test_ECDSA.mag"
%Time: 4.230
%\end{lstlisting}


Another simple idea is to evaluate only once the inverse of $s$, it saves only $0.1$ seconds, but it is still worth it (you can see more on \href{https://github.com/giacomoborin/project2_MAGMA/issues/13}{the relative issue on github}).

\section{Pohlig-Hellman}

The Pohlig-Hellman method is an algorithm for the evaluation of the discrete logarithm %with base element of finite order
, i.e. given $P$ and $Q$ in a group $G$ such that $P$ has finite order $N$ and exists $k\in \{0,...,N-1\}$ such that $kP = Q$ the algorithm finds $k$. 

\begin{nota}
	I will use additive notation for the group operation with neutral element $O$ since we are requested to implement this algorithm for solving discrete logarithm for Elliptic Curves. 
\end{nota}

\begin{idea} \label{idea:ecdlp}
	Consider the factorization:
\begin{equation*}
	N = \prod_{i=1}^r p_i^{e_i}.
\end{equation*}
	Solve now the discrete logarithm modulo $p_i^{e_i}$ for all $i = 1,...,r$ and use these values to evaluate $k$ using the Chinese Reminder Theorem. 
\end{idea}

Let's see a first naive version of the strategy\footnote{I know that this is indeed very similiar to a real code, but for me it is easier to understand} for finding $k \,\text{mod}\, p^e$:

\begin{algo}\label{algo:ecdlp_naive}

	\begin{enumerate}
		\item \label{enum:store} Compute $T = \{ (j,j\left(\frac{N}{p}P\right)) \,|\, j = 0,...,q-1 \}$.
		\item Assign $i := 0$, $Q_0 := Q$
		\item \label{enum:while} find $(j,R)\in T$ such that $R = \frac{N}{p^{i+1}}Q_i$ and assign $k_i := j$
		\item Increment $i := i + 1$, then:
		\item \label{enum:if} If $i < e$ assign $Q_i := Q_{i-1} - k_{i-1} p^{i-1}P$ and return to step \ref{enum:while}
		\item Then we have $k \equiv k_0 + k_1p + ... + k_{e-1}p^{e-1} \mod q^e$ \label{enum:final_dlp}.
	\end{enumerate}

\end{algo}


Obviously the procedure terminates, but we still need to prove that the step \ref{enum:final_dlp} is correct.

\begin{prop}
	\label{prop:corr_dlp}
	Consider $k$ written in base $p$ as $k = \hat{k}_0 + \hat{k}_1p + \hat{k}_2p^2 + ...$, then we have that:

	for each $i \in \{0,...,e-1\}$ at the step \ref{enum:while} hold that 
	$\hat{k}_i = k_i$ and $Q_i = (\hat{k}_ip^i + \hat{k}_{i+1}p^{i+1} + ... )P$
\end{prop}

\begin{proof}
	We will prove this by induction on $i \in \{ 0 ,..., e-1\}$.

	\textbf{Base case}: $i=0$. Trivially we have that $Q_0 = Q = kP = (\hat{k}_0 + \hat{k}_1p + \hat{k}_2p^2 + ...)P$. Observe now that:
	\begin{equation}
		\label{eq:prop:base}
		\frac{N}{p^{0+1}}Q_0 = \frac{N}{p}\hat{k}_0 P + N(\hat{k}_1 + \hat{k}_2p + ...)P \eqb^* \frac{N}{p}k_0 P + O = \hat{k}_0 \frac{N}{p} P
	\end{equation}
	where in $*$ we have used that $NP = O$. Observe that $p$ divides $N$. Since $j$ from step \ref{enum:while} is in $\{0,...,p-1\}$ we have $\hat{k}_0 = j = k_0$.

	\textbf{Induction step}: prove the result for $i \in \{1,...,e-1\}$ assuming that it holds for $i-1$. 

	By the step \ref{enum:if} we have that:
	\begin{multline*}
		Q_i := Q_{i-1} - k_{i-1} p^{i-1}P = (\text{induction on }i-1\text{ for } k_{i-1} \text{ and } Q_{i-1}) \\
		= (\hat{k}_{i-1}p^{i-1} + \hat{k}_{i}p^{i} + ... )P - \hat{k}_{i-1} p^{i-1}P = (\hat{k}_ip^i + \hat{k}_{i+1}p^{i+1} + ... )P.
	\end{multline*}
	So we can evaluate $R$ :
	\begin{multline*}
		\frac{N}{p^{i+1}}Q_i = \frac{N}{p^{i+1}}(\hat{k}_ip^i + \hat{k}_{i+1}p^{i+1} + ... )P = \\
		= \hat{k}_i \frac{N}{p} P + N(\hat{k}_{i+1} + \hat{k}_{i+1}p + ...)P= \hat{k}_i \frac{N}{p} P + O = \hat{k}_i \frac{N}{p} P 
	\end{multline*}
	So in the same way $\hat{k}_i = j = k_i$. Observe that these are the same calculation of the base case and also we have that $p^{i+1}$ divides $N$ since $i<e$. 
\end{proof}

Trivially it follows that:

\begin{cor}
	The result in step \ref{enum:final_dlp} is correct.
\end{cor}

So to find the discrete logarithm we only have to repeat the previous steps for each $p_i^{e_i}$. We can then solve the system 
\[
	k \mod p_i^{e_i} \quad \text{ for } i=1,...,r
\]
using the Chinese Reminder Theorem and get the desired $k \in \{0,...,N-1\}$. 

The strenght of this algorithm is that we are performing the discrete logarithm by linear search $\sum e_i$ times in sets of cardinality $p_i$ (having then a complexity of $O(e_j p_j)$ where $p_j$ is the greatest prime factor) instead of one time for all the $N$ values in $\left< P \right>$. So obviously if the factors of $N$ are small we obtain a result much better than $O(\sqrt{N})$ of other general algorithms (like Shanks or Pollard-Rho). 

For the description (and implementation) of the algorithm I have used \linebreak
\cite[Section 5.2.3]{washington} and \cite[Section 7.2.3]{stinson} (written in multiplicative notation and with a more costructive description). 

\subsection{Implementation}

For now on I will use the same notation used in the code of\\ \texttt{ECDLP}\verb|_|\texttt{PohligHellman(q, E, P, r, Q)}.

Let's start with considering what we have \textbf{not} implemented, i.e. the functions already contatined in MAGMA that we have decided to use since they are more efficient:
\begin{itemize}
	\item \verb|Factorization|, necessary to factor the order of the point \verb|r|
	\item \verb|CRT|, that at the end evaluate the solution of the system modulo \verb|r| of congruences resulting after the for loop.
	\item \verb|IsPrimitive|, I will explain later why we need it.
	\item The \verb|EllipticCurve| \href{http://magma.maths.usyd.edu.au/magma/handbook/elliptic_curves}{structure} and all its functions (in particular the sum and the doubling). 
\end{itemize}

The first working implementation (\href{https://github.com/giacomoborin/project2_MAGMA/blob/2416fa58ca58ef91075fc4a52427d68a5fa182c1/ECDLP.mag}{2416fa5}) of the code followed step by step the Algorithm \ref{algo:ecdlp_naive}. It was very slow because of two principal reasons:
\begin{enumerate}
	\item \label{enum:append} Extensive use of the command \verb|Append|, slow since memory allocation for sequences is expensive, particularly in MAGMA.
	\item \label{enum:map} The use of the command \texttt{map<|>}, similiar to the dictionary in Python, but sadly not efficient in MAGMA. 
\end{enumerate}
The second command was used to perform the steps \ref{enum:store} and \ref{enum:while} of the procedure, that we have individuated as the most time consuming parts of the method:

\begin{prob}[Evaluation]
	Evaluate and store all the values $\{ (j,j\left(\frac{N}{p}P\right)) \,|\, j = 0,...,q-1 \}$ (step \ref{enum:store}). In the code $\frac{N}{p}P$ is \verb|coeffP|. 
\end{prob}

\begin{prop}[Search]
	Search into the evaluated points and return the corresponding index (step \ref{enum:while})
\end{prop}

To solve these problems I have observed that we can consider two different cases: $e=1$ and $e>1$ (where $e$ is the exponent of the prime in the factorization).

\subsection{Case e=1}
Here we can solve the two problems togheter perferming in parallel the evaluation of \verb|j*coeffP| while checking if it is equal to \verb|Qs|. In this way we the memory allocation is negligible and we will need on average \verb|prime|$/2$ operations. 

Let's look more in details to the implementation choices in this case. Obviously we start evaluating \texttt{Qs} (corresponding to $\frac{N}{r}Q$). If it is the infinity point we return directly \verb|k|$=k_0 = 0$ otherwhise we distinguish two other cases. 

In the second one we do the simple evaluation starting from $k = 1$ and $\verb|Point| = \verb|coeffP|$, then increment $k$ by $1$ and \verb|Point| by \verb|coeffP| until we find \verb|Point eq Qs|.

In the first we look if $2$ is primitive in $\mathbb{Z}_p$, in this way to get all the multiples of \verb|coeffP| we can evaluate instead $2^j\verb|coeffP|$ for $j = 0, ..., p-2$. 

So insted of incrementing $k$ we multiply it by $2 \mod p$ and we double \verb|Point|, that is sligtly faster with respect to adding points. (commit \href{https://github.com/giacomoborin/project2_MAGMA/commit/d2d2692170bebfa2b465307761de5c7ee52121bf}{d2d2692})

\subsection{Case e>1}

In this case we go straight with the computation and the storing of points. The only two improvements added where the pre-initialization of the array \verb|T| to reduce new memory allocation and the use of the function \verb|Position| to find the index.

Observe that also \verb|K| and \verb|Qs| where pre-initilized with buffer values. 

\begin{rem} %TODO
	Doing log insted of the search good, but forbidden
\end{rem}


\section{Index Calculus}

\subsection{Implementation}

Dario had done the first implementation, but there was a problem: not every solution of the linear system gives the discrete logarithm. We can solve in two ways:
\begin{itemize}
	\item Removing columns with all zeros \href{https://github.com/giacomoborin/project2_MAGMA/pull/30/commits/4b0b67d0dcbe51f01058c64a06a1c39fdb5cf56e}{4b0b67d}
	\item Inserting a check, if not passed try adding more equations \href{https://github.com/giacomoborin/project2_MAGMA/pull/30/commits/e17fe016088c6746c46d52d7154922060f8e5366}{e17fe01}
\end{itemize}



Using append bad \href{https://github.com/giacomoborin/project2_MAGMA/commit/d12863968fe66504486fa7fea78929ab2aa98f43}{d128639}. 

\subsubsection{B-smoothing}

Mathematically it should be better to proceed in different ways, as done in the commit \href{https://github.com/giacomoborin/project2_MAGMA/commit/80399ac928cf19e009451f174adc4138283580f2}{80399ac}. Sadly it is too slow (MAGMA mistery).



\section{Solovay-Strassen}

The Solovay-Strassen test is a primality test based on the Euler's criterion:
\begin{teo}\label{teo:eu_quad}
	If $p$ is a prime integer, than for any integer $a \in \ZZ$ we have:
	\[ a^{\frac{p-1}{2}} \equiv \left(\dfrac{a}{p}\right) \mod p \]
\end{teo}

The term on the right is the Legendre Symbol, that is equal to $0$ if $p$ divides $a$, to $1$ if it is a quadratic residue modulo $p$\footnote{if exists $b$ integer such that $a \equiv b^2 \mod p$} and $-1$ otherwhise. The generalization of the Legendre Symbol for all integers $n = p_1^{e_1} \cdots p_r^{e_r}$ is the Jacobi Symbol: 

\[ \left(\dfrac{a}{n}\right) := \left(\dfrac{a}{p_1}\right)^{e_1} \cdots \left(\dfrac{a}{p_r}\right)^{e_r} \] 
	
Since for general composite integers the theorem \ref{teo:eu_quad} won't always hold we can exploit this for a primality test. Given an odd integer $n$ the idea is to evaluate the two terms on a random integer $a\in \{2,...,n-1\}$ separately, see if they are equal, if no then $n$ is composite, otherwhise we change $a$ and repeat. We can conclude that $n$ is composite also if the Jacobi Symbol is equal to $0$, in fact this would imply that exists a prime $p_i$ dividing $a<n$ and $n$, so $n$ has a proper factor. 

\begin{prob}\label{prob:jacobi}
	How do we evaluate the Jacobi Symbol without knowing the factorization of $n$?
\end{prob}

\begin{prob}\label{prob:eff_ss}
	What is the probability for a composite number to pass the test $m$ times?
\end{prob}

It is possible to prove that no composite number pass the test for all $a\in\{0,...,n-1\}$ and in particular it fails in at least $1/2$ of them. So we have that 
\begin{equation}
	\label{eq:prob_SS}
\PP(n \text{ pass the SS test }m\text{ times}|n\text{ is composite})\leq \frac{1}{2^m} .
\end{equation}
Observe that what we want is $\PP(n\text{ is composite}|n \text{ pass the SS test }m\text{ times})$, but it is possible to use Bayes' theorem to compute:
\begin{equation}
	\label{eq:prob_SS_good}
	\PP(n\text{ is composite}|n \text{ pass the SS test }m\text{ times})
	\leq
	\frac{\log(n) - 2}{\log(n) - 2 + 2^{m+1}}
\end{equation}

You can see the proof of this at page 208 of \cite[Section 6.4.2]{stinson}.

In our implementation we repeat the test $m=10$ times and the test vectors are integers $n \approx 2^20 \approx e^{13.9}$, se we get a pseudoprime with probability:



To evaluate the Jacobi Symbol we don't have to use the factorization! A possible way to implement it is inserted in the file (commit \href{https://github.com/giacomoborin/project2_MAGMA/commit/aa03960b86ec942f5f35c55e297850a3e2b2beba}{aa03960}.

Obviously using sequence is bad for MAGMA, so I've written a sligtly faster version in commit \href{https://github.com/giacomoborin/project2_MAGMA/commit/2ffe332f8ee782b20a079694f1c1cf9363aae3d0}{2ffe332}.


However the function \verb|JacobiSymbol| is by far the more efficient thing possible in MAGMA today and for our skills. 


\section{Lehman}

\appendix


\newpage
\printbibliography


\end{document}
