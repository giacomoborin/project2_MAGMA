\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amssymb,amsmath,amsthm,mathtools} 
\usepackage{tikz-cd,wrapfig}
\usepackage{tcolorbox}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{enumitem}
\usepackage{pdfsync}
\usepackage{amstext} % for \text macro
\usepackage{array}   % for \newcolumntype macro
% \newcolumntype{C}{>{$}c<{$}} % math-mode version of "C" column type
%Personal package
\usepackage{listings}
\usepackage{lstlang0}
\usepackage{bm}
\usepackage{csquotes}


%Commands
\newcommand{\DD}{\mathcal{D}}
\DeclareMathOperator{\sgn}{sgn}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\FT}{\mathcal{F}}
\DeclareMathOperator{\eqb}{=}
\DeclareMathOperator{\ifff}{\iff}


% Theorem definitons 
\theoremstyle{plain}
\newtheorem{teo}{Theorem}[section]
\newtheorem{lem}[teo]{Lemma}
\newtheorem{prop}[teo]{Proposition}
\newtheorem{cor}[teo]{Corollary}
\newtheorem*{form}{Formula}

\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newtheorem{rems}[rem]{Remarks}

\theoremstyle{definition}
\newtheorem{deff}[teo]{Definiton}
\newtheorem{idea}{Idea}
\newtheorem*{nota}{Notation}

%Bibliography
\usepackage[backend=biber, style=alphabetic, maxnames = 8, giveninits=true,isbn=false,eprint=false]{biblatex}
%other_styles:numeric_authortitle
\addbibresource{biblio.bib}


\usepackage{hyperref}



\title{Report for the MAGMA project}
\author{Giacomo Borin}

\begin{document}

\maketitle

\begin{abstract}
	The report contain the implementation of 5 algorithms:
	\begin{itemize}
		\item ECDSA, a digital signature scheme based on algebraic curves.
		\item Pohlig Hellman alorithm for solving discrete logarithm problem for Algebraic curves. Particularly efficient when the base point has order with only small primes in the factorization
		\item Index Calculus algorithm for solving discrete logarithm problem for in finite fields of prime order using linear algebra and B-smooth sieving.
		\item Solovay-Strassen primality test, based on the evaluation of the Jacobi Symbol.
		\item Lehman factorization algorithm, based on a modification of the Fermat factorization algorithm.
	\end{itemize}

	The requests for the report are:


	Assuming that a team has passed the first phase, then each team member must submit an individual report on the project. The report must be written in English and not more than 15 pages.
	The report must include the following:
	\begin{itemize}
		\item your personal contribution to the team project (0-2 points)
		\item a complete overview of the mathematical problems behind the algorithms (0-4
points)
		\item an in-depth explanation of the implementative choices (0-4 points)
	\end{itemize}
	You must also submit the code of the project. This may include some improvements that you personally added after the project submission.


\end{abstract}


\section{ECDSA}

We have implemented the algorithm from~\cite[Section 6.6]{washington}.

\lstinputlisting[language=magma, firstline=17, lastline=38]{../ECDSA.mag}
\lstinputlisting[language=magma, firstline=41, lastline=60]{../ECDSA.mag}

I've personally implemented all the code and a good part of the test vectors(it didn't took a lot of time), while Dario helped with debugging.

\subsection{Implementation choiches}

- following the washington

It would be faster to use $k = 4$ as Sony, since it simplifies a lot the evaluation of $kG$ (in fact it would require only two doublings) but it would be very bad for security. However I have tried to use again the idea at the commit \href{https://github.com/giacomoborin/project2_MAGMA/commit/1209afbbb3bed86d26ebf342bf6f43453de3e795}{1209afb}.

Some evaluation can be seen in the \href{https://github.com/giacomoborin/project2_MAGMA/pull/36}{associated pull request}.

\begin{lstlisting}[language = magma]
> load "ECDSA.mag"; // k random
Loading "ECDSA.mag"
> load "Test_ECDSA.mag";
Loading "Test_ECDSA.mag"
Time: 6.130
> load "ECDSA.mag"; // k = 4    
Loading "ECDSA.mag"
> load "Test_ECDSA.mag";
Loading "Test_ECDSA.mag"
Time: 4.230
\end{lstlisting}


Another simple idea is to evaluate only once the inverse of $s$, it saves only $0.1$ seconds, but it is still worth it (you can see more on \href{https://github.com/giacomoborin/project2_MAGMA/issues/13}{the relative issue on github}).

\section{Pohlig-Hellman}

The Pohlig-Hellman method is an algorithm for the evaluation of the discrete logarithm %with base element of finite order
, i.e. given $P$ and $Q$ in a group $G$ (written with additive notation and neutral element $O$) such that $P$ has finite order $N$ and exists $k\in \{0,...,N-1\}$ such that $kP = Q$ the algorithm finds $k$. 

\begin{idea} \label{idea:ecdlp}
	Consider the factorization:
\begin{equation*}
	N = \prod_{i=1}^r p_i^{e_i}.
\end{equation*}
	Solve now the discrete logarithm modulo $p_i^{e_i}$ for all $i = 1,...,r$ and use these values to evaluate $k$ using the Chinese Reminder Theorem. 
\end{idea}

Let's see a first naive version of the strategy\footnote{I know that this is indeed very similiar to a real code, but for me it is easier to understand} for finding $k \,\text{mod}\, p^e$:
\begin{enumerate}
	\item Compute $T = \{ (j,j\left(\frac{N}{p}P\right)) \,|\, j = 0,...,q-1 \}$.
	\item Assign $i := 0$, $Q_0 := Q$
	\item \label{enum:while} find $(j,R)\in T$ such that $R = \frac{N}{p^{i+1}}Q_i$ and assign $k_i := j$
	\item Increment $i := i + 1$, then:
	\item \label{enum:if} If $i < e$ assign $Q_i := Q_{i-1} - k_{i-1} p^{i-1}P$ and return to step \ref{enum:while}
	\item Then we have $k \equiv k_0 + k_1p + ... + k_{e-1}p^{e-1} \mod q^e$ \label{enum:final_dlp}.
\end{enumerate}

Obviously the procedure terminates, but we still need to prove that the step \ref{enum:final_dlp} is correct.

\begin{prop}
	\label{prop:corr_dlp}
	Consider $k$ written in base $p$ as $k = \hat{k}_0 + \hat{k}_1p + \hat{k}_2p^2 + ...$, then we have that:

	for each $i \in \{0,...,e-1\}$ at the step \ref{enum:while} hold that 
	$\hat{k}_i = k_i$ and $Q_i = (\hat{k}_ip^i + \hat{k}_{i+1}p^{i+1} + ... )P$
\end{prop}

\begin{proof}
	We will prove this by induction on $i \in \{ 0 ,..., e-1\}$.

	\textbf{Base case}: $i=0$. Trivially we have that $Q_0 = Q = kP = (\hat{k}_0 + \hat{k}_1p + \hat{k}_2p^2 + ...)P$. Observe now that:
	\begin{equation}
		\label{eq:prop:base}
		\frac{N}{p^{0+1}}Q_0 = \frac{N}{p}\hat{k}_0 P + N(\hat{k}_1 + \hat{k}_2p + ...)P \eqb^* \frac{N}{p}k_0 P + O = \hat{k}_0 \frac{N}{p} P
	\end{equation}
	where in $*$ we have used that $NP = O$. Since $j$ from step \ref{enum:while} is in $\{0,...,p-1\}$ we have $\hat{k}_0 = j = k_0$.

	\textbf{Induction step}: prove the result for $i \in \{1,...,e-1\}$ assuming that it holds for $i-1$. 

	By the step \ref{enum:if} we have that:
	\begin{multline*}
		Q_i := Q_{i-1} - k_{i-1} p^{i-1}P = (\text{induction on }i-1) \\
		= (\hat{k}_{i-1}p^{i-1} + \hat{k}_{i}p^{i} + ... )P - k_{i-1} p^{i-1}P = (\hat{k}_ip^i + \hat{k}_{i+1}p^{i+1} + ... )P
	\end{multline*}	
	
\end{proof}

Trivially it follows that:

\begin{cor}
	The result in step \ref{enum:final_dlp} is correct.
\end{cor}

\section{Index Calculus}

\subsection{Implementation}

Dario had done the first implementation, but there was a problem: not every solution of the linear system gives the discrete logarithm. We can solve in two ways:
\begin{itemize}
	\item Removing columns with all zeros \href{https://github.com/giacomoborin/project2_MAGMA/pull/30/commits/4b0b67d0dcbe51f01058c64a06a1c39fdb5cf56e}{4b0b67d}
	\item Inserting a check, if not passed try adding more equations \href{https://github.com/giacomoborin/project2_MAGMA/pull/30/commits/e17fe016088c6746c46d52d7154922060f8e5366}{e17fe01}
\end{itemize}



Using append bad \href{https://github.com/giacomoborin/project2_MAGMA/commit/d12863968fe66504486fa7fea78929ab2aa98f43}{d128639}. 

\subsubsection{B-smoothing}

Mathematically it should be better to proceed in different ways, as done in the commit \href{https://github.com/giacomoborin/project2_MAGMA/commit/80399ac928cf19e009451f174adc4138283580f2}{80399ac}. Sadly it is too slow (MAGMA mistery).



\section{Solovay-Strassen}


To evaluate the Jacobi Symbol we don't have to use the factorization! A possible way to implement it is inserted in the file (commit \href{https://github.com/giacomoborin/project2_MAGMA/commit/aa03960b86ec942f5f35c55e297850a3e2b2beba}{aa03960}.

Obviously using sequence is bad for MAGMA, so I've written a sligtly faster version in commit \href{https://github.com/giacomoborin/project2_MAGMA/commit/2ffe332f8ee782b20a079694f1c1cf9363aae3d0}{2ffe332}.


However the function \verb|JacobiSymbol| is by far the more efficient thing possible in MAGMA today and for our skills. 


\section{Lehman}

\appendix


\newpage
\printbibliography


\end{document}
