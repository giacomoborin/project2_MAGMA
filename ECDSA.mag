

function ECDSA_Signing(q,E,G,r,d,m)
/*
     INPUTS: -q is the number of elements of the finite
              field over which is defined the curve
             -E is the elliptic curve
             -G is the base point of E
             -r is the order of the point G
             -d is Alice’s private key
             -m is the message to be signed
     OUTPUT: -(R,s) is the digital signature
*/
	
	// Choose random element e mod r.
	k := Random(1,r-1);
	// Compute R = kG ∈ E(Fp) and then,
	R := k*G;
	//	
	s := (m + d*Integers()!(R[1]) )*Modinv(k,r) mod r;
	return R,s;
end function;


function ECDSA_Verification(q,E,G,r,Q,m,R,s)
/*
     INPUTS: -q is the number of elements of the finite
              field over which is defined the curve
             -E is the elliptic curve
             -G is the base point of E
             -r is the order of the point G
             -Q is Alice‚Äôs public key
             -m is the message to be signed
             -R is the first part of the digital signature
             -s is the second part of the digital signature
     OUTPUT: -bool is a boolean that says if the
              sign is valid
*/
	i := Modinv(s,r);
	u1 := m*i mod r;
	u2 := Integers()!(R[1])*i mod r;
	return (u1*G + u2*Q) eq R;
end function;


//-------------------------------------------
//----------------TEST PART------------------
//-------------------------------------------


load "test_ECDSA_giacomo.mag";

procedure test_ECDSA()
	for test in TestECDSA do
		el:=test[1];
		M:=test[2];
		q:=el[1][1];
		E:=EllipticCurve( [GF(q)!el[1][2],el[1][3]]  );
		P:=E!el[1][4];
		r:=el[1][5];
		d:=el[2][1];
		for m in M do
			R,s:=ECDSA_Signing(q,E,P,r,d,m);
			if not ECDSA_Verification(q, E, P, r, E!el[1][6], m, E!R, s) then
				"Error! These are test and m:\n";
				test; m; 
				break; 
			end if;
		end for;
	end for;
end procedure;

time test_ECDSA();

