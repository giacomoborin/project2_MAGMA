// 5. Write a function ECDLP PohligHellman(q,E,P,r,Q) that breaks the Elliptic
// Curve Discrete Logarithm Problem (ECDLP) with the following specifications:
//
// NAME: ECDLP_PohligHellman(q,E,P,r,Q)
//
// INPUTS: -q is the number of elements of the finite field over which is defined the curve
//         -E is the elliptic curve
//         -P is the base point of the curve
//         -r is the order of the point P
//         -Q is a multiple of P
//
// OUTPUT: -d is the factor of Q with respect to P
//
// Remark. In the previous functions q, r and d are integers: in particular q
// defines the finite field Fq and 1 < d < r; E is an elliptic curve; P and Q
// are points over the elliptic curve E such that Q = d Â· P. You will find the
// description of the algorithms in the attached files.

function ECDLP_PohlingHellman(q, E, P, r, Q)
  FactorsOfr:=Factorization(r);
  KSET:=[];
  
  for i in [1..#FactorsOfr] do
  
    prime:=FactorsOfr[i][1];
    e:=FactorsOfr[i][2];
    
    coeff:=Integers()!(r/prime); //Remark: r is divisible by prime
    coeffP:=coeff*P;
    ImageOfT:=[<i*coeffP,i> : i in [0..prime-1]];
    T:=map< [ImageOfT[i][1]: i in [1..prime]] -> [0..prime-1]  | ImageOfT>; //This is the nearest thing to a dictionary in Magma

    K:=[]; //this will be the sequence that contains all the k_(i-1)
    Qs:=[Q]; //this will be the sequence that contains all the Q_(i-1)

    K:=Append(K, T(coeff*Qs[1])); //coeff*Q=k_0(coeff*P), hence T(coeff*Q)=k_0

    for i in [2..e] do
      Qs:=Append(Qs, Qs[i-1]-(K[i-1]* ((prime^(i-2))*P) ));
      K:=Append(K, T(Integers()!(coeff/(prime^(i-1)))*Qs[i])); //coeff*_i=k_i(coeff*P), hence T(coeff*Q_i)=k_i
    end for;

    KSET:=Append(KSET, &+[K[i]*(prime^(i-1)) : i in [1..e]] mod (prime^e)); 
  end for;

  return ChineseRemainderTheorem(KSET, [FactorsOfr[i][1]^FactorsOfr[i][2] : i in [1..#FactorsOfr]]);
  
end function;
