// 5. Write a function ECDLP PohligHellman(q,E,P,r,Q) that breaks the Elliptic
// Curve Discrete Logarithm Problem (ECDLP) with the following specifications:
//
// NAME: ECDLP_PohligHellman(q,E,P,r,Q)
//
// INPUTS: -q is the number of elements of the finite field over which is defined the curve
//         -E is the elliptic curve
//         -P is the base point of the curve
//         -r is the order of the point P
//         -Q is a multiple of P
//
// OUTPUT: -d is the factor of Q with respect to P
//
// Remark. In the previous functions q, r and d are integers: in particular q
// defines the finite field Fq and 1 < d < r; E is an elliptic curve; P and Q
// are points over the elliptic curve E such that Q = d Â· P. You will find the
// description of the algorithms in the attached files.



///////////////////////////////////FUNCTION///////////////////////////////////
function ECDLP_PohlngHellman(q, E, P, r, Q)
	FactorsOfr:=Factorization(r);
	KSET:=[1..#FactorsOfr];

	for i in [1..#FactorsOfr] do
	  
		prime:=FactorsOfr[i][1];
		e:=FactorsOfr[i][2];
		coeff:=(r div prime); //Remark: r is divisible by prime
		coeffP:=coeff*P;
		K:=[0 : _ in [1..e]]; //this will be the sequence that contains all the k_(i-1)
		Qs:=[Q : _ in [1..e]]; //this will be the sequence that contains all the Q_(i-1)


		if e gt 1 then
			//T := [ i*coeffP : i in [0..prime-1]];
			
			T := [ Zero(E) : i in [1..prime]];
			for j in [2..prime] do
				T[j] := coeffP + T[j-1];
			end for;
			

			K[1] := Position(T,coeff*Qs[1]) - 1; //coeff*Q=k_0(coeff*P), hence T(coeff*Q)=k_0

			for j in [2..e] do
				Qs[j]:= Qs[j-1]-(K[j-1]* ((prime^(j-2))*P) );
				K[j]:= Position(T,(coeff div (prime^(j-1)))*Qs[j]) - 1; //coeff*_i=k_i(coeff*P), hence T(coeff*Q_i)=k_i
			end for;
		else
			Qs := coeff*Q;
			if Qs eq Zero(E) then
				K := [0];
			elif prime gt 2 and IsPrimitive(2,prime) then 
				k := 1;
				Point := coeffP;
				while Point ne Qs do
					Point := 2*Point;
					k := (2*k) mod prime;
				end while;
				K := [k];
			else
				k := 1;
				Point := coeffP;
				while Point ne Qs do
					Point +:= coeffP;
					k +:= 1;
				end while;
				K := [k];
			end if;
		end if;
		

		KSET[i] := Seqint(K,prime);
		//KSET[i] :=&+[K[j]*(prime^(j-1)) : j in [1..e]] ; 
	end for;

	return CRT(KSET, [f[1]^f[2] : f in FactorsOfr]);
end function;


///////////////////////////////////TV///////////////////////////////////

load "Test_ECDLP.mag";
procedure test_pohlig_hellman()
	for i in [1..#TestPH] do 
		q:= TestPH[i][1][1];
		A:= GF(q)!TestPH[i][1][2];
		B:= GF(q)!TestPH[i][1][3];
		E:=EllipticCurve([A,B]);
		P:= E!TestPH[i][1][4];
		r:=TestPH[i][1][5];
		Q:=E!TestPH[i][1][6];
		d:= ECDLP_PohlngHellman(q,E,P,r,Q);
		if d ne TestPH[i][2][1] then
			"Error! The problem is for test:\n";
			TestPH[i]; i; break;
		end if;
	end for;
end procedure;

time test_pohlig_hellman();
