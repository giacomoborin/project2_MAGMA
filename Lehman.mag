


// isqrt(n,  u) which  gives as  its  value  the  smallest  positive  integer  j  such  that  j^2 >= n and  gives to  u the  corresponding  value  of  j^2  — n
function isqrt(n)
	j := Ceiling(Sqrt(n));
	return j,j^2-n;
end function;


// quadratic residue modulo 279
QR := [false : _ in [1..279]];
for i in [1..279] do
	QR[(i^2 - 1) mod 279 + 1]:= true;
end for;






function Factorization_Lehman(N)
/*
     INPUTS:  -N is the semiprime
     OUTPUT:  -p is the smallest prime factor of N
              -q is the largest prime factor of N
*/
	// Bho proviamo a definire r
	r := Floor(N^(1/3));
	// Bho proviamo a dare valore ai c e large
	C := [ 	<1,0,[30]>,
		<4,-24,[48,24,24,24]>,
		<4,-12,[24,24,48,24]>,
		<4,-18,[36,36,72,36]>,
		<8,-6, [12,36,24,12,24,12,24,36]>,
		<2,-2, [4,2]>,
		<1,-1, [2]>
	     ];
	n := N;
	for array in C do
		m:= array[1];
		m0 := array[2];
		c := array[3];
		// this is the function large(m,m0,r,N,c);
		s := 1; k := m0;
		k := k + c[s];
		// forse if √® meglio ??
		s := (s mod m) + 1;
		while k le r do
			x,u := isqrt(4*k*n); 
			buff,t := isqrt(n/k);
			j := (buff - 1)/(4*(r+1));
			if (x+k) mod 2 eq 0 then 
				i1 := 1;
				u := u + 2*x +1;
				x := x + 1;
			else
				i1 := 0;
			end if;

			odd := (k mod 2) eq 1;
			if odd then 
				jump := 4;
			else 
				jump := 2;
			end if;

			// speed up : compress them
			if odd then 
				if ((k+n) mod 4) eq (x mod 4) then
					i1 := i1 + 2;
					u := u + 4*(x+1);
					x := x + 2;
				end if;
			end if;

			for i in [i1..Floor(j+1) by jump] do
				if QR[(u-1) mod 279 + 1] then
					y,t := isqrt(u);
					if t eq 0 then
						// VICTORY
						p := Gcd(x-y,n);
						q := n div p;
						return Min(p,q),Max(p,q);
					end if;
				end if;
			end for;

			k := k + c[s];
			s := (s mod m) + 1;
		end while;
	end for;
	return 1;
end function;


Factorization_Lehman(33431);
